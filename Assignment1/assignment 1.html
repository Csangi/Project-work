<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0050)https://www.cs.fsu.edu/~myers/cop4530/hw/hw01.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  
    
  <meta name="GENERATOR" content="Mozilla/4.79 [en] (Win98; U) [Netscape]">
    
  <meta name="Author" content="Bob Myers">
  <title>assignment 1</title>
</head>

<body text="#000000" bgcolor="#ffffff">
  
<h2>Programming Assignment #1</h2>
Due: Mon, Sept 12

<h2>Objective</h2>
This assignment will provide practice with a templated vector class, along 
with practice on the basic concept of an iterator over a container.

<h2>Task</h2>

In your prior course, you should have seen examples of building array-based 
classes with dynamically managed arrays inside.  This is the core concept 
of a vector class -- a container that stores a dynamically managed array 
internally.
 
<p>For this assignment you will implement a templated vector class, along 
with an associated iterator class for helping with generic container 
traversals. The following starter files are provided for you:

</p><ul>

<li><a href="https://www.cs.fsu.edu/~myers/cop4530/hw/hw1files/tvector.h"><tt>tvector.h</tt></a> -- provides the 
<b>declarations</b> of the template classes <tt>TVector</tt> (the vector
class) and <tt>TVectorIterator</tt> (an associated class to help with 
traversal of the container). </li>

<li><a href="https://www.cs.fsu.edu/~myers/cop4530/hw/hw1files/driver.cpp"><tt>driver.cpp</tt></a> -- contains some 
sample test calls to the vector class functions, but should NOT be 
considered a complete or thorough set of tests. You will need to create 
more test cases to fully test your class features.  This driver is provided 
to help illustrate some of the basic class features and concepts, including 
the use of iterators.  Note that this driver does not exercise all functions 
in the vector class.  Write your own calls to test them all!</li>

<li><a href="https://www.cs.fsu.edu/~myers/cop4530/hw/hw1files/driver_output.txt"><tt>driver_output.txt</tt></a> 
-- contains the output from running the above sample driver program 
</li>

</ul>


<p>Your job will be to finish this templated set of classes by defining 
each of the functions in the <tt>tvector.h</tt> file. These should be 
defined in a file called: </p><ul><tt>tvector.hpp</tt></ul>

Note that there is already a <tt>#include</tt> at the bottom of 
<tt>tvector.h</tt> where your definition file will be brought in.  This 
illustrates a pretty standard format for setting up a templated class.
<br>&nbsp;

<h2>Iterators</h2>

The small class called <tt>TVectorIterator</tt> is a helper class that can 
be used in conjunction with the vector class.  This is a common feature 
used in container classes like this.  The purpose of an iterator is to 
provide a common and non-implementation-specific way of traversing a 
container, so that mulitple containers could potentially use common 
algorithms (like sorting and searching functions, for example).  This will 
be explored and explained more in the course.  For the iterator class in 
this assignment, here is a brief sample use:

<pre style="position: relative;">  // suppose that V is a vector storing ints, and it has 
  //   already been populated with the values 3, 6, 9, 12, 15, 18, 21

  // this call would retrieve a vector iterator over the container V
  TVectorIterator&lt;int&gt; itr = V.GetIterator();

  // at this point, itr currently is positioned at the first element in 
  // the list (the 3).

  int x = itr.GetValue();		// x would now store 3
  itr.Next();				// itr has advanced to the 6
  int y = itr.GetValue();		// y would now store 6
  itr.Next();
  itr.Next();				// we have now advanced to the 12
  int z = itr.GetValue();		// z now stores 12
 
  itr.Previous();			// now we have moved backwards, to the 9
  int a = itr.GetValue();		// a stores 9.    etc.
<div class="open_grepper_editor" title="Edit &amp; Save To Grepper"></div></pre>
This class essentially helps us walk through the container in a fairly 
easy way, with calls to <tt>Next()</tt> and <tt>Previous()</tt> to move 
around.


<h2>Program Details</h2>

Here are general descriptions of the two classes you are to define, 
along with a general description of each function's task.

<h3>1) class TVector</h3>

The member data of this class consists of a pointer to a dynamically 
managed array, along with tracking variables for the capacity and the size.  
Note that the capacity refers to how much space is currently allocated, and 
size refers to how many data items are currently stored.  There is also a 
dummy variable of type T that can be used for error-checking situations. 
Specifically, some of the functions specify to return a stored data item, 
but if you encounter a situation like an empty container or other situation 
where there would not BE a valid data item, you can return a reference to 
the dummy object instead. This is needed because some such functions are 
pass-by-reference (so that the retrieved item can be modified by the caller 
under normal situations).  There is also a static constant called 
SPARECAPACITY, which will be used to add some extra capacity when 
constructing vector objects.

<p>Function descriptions
</p><ul>

<li><b>Default constructor</b> -- creates an empty vector (no data 
elements), with capacity SPARECAPACITY.

<br>&nbsp;
</li>

<li><b>TVector(T val, int num)</b> -- creates a vector containing "num" 
copies of the data element "val", and the capacity should be set to 
whatever is needed for the stored data, plus the SPARECAPACITY amount.
<br>&nbsp;
</li>

<li><b>Clear</b> -- clear out the vector so that it represents an empty 
container (no data elements).
<br>&nbsp;
</li>

<li><b>Big Five</b>
 <ul>
 <li>Destructor -- appropriate clean-up, no memory leaks</li>
 <li>Copy constructor -- deep copy</li>
 <li>Copy assignment operator -- deep copy</li>
 <li>Move constructor -- constructor with standard move semantics</li>
 <li>Move assignment operator -- assignment with standard move semantics</li>
 </ul>
<br>
</li>

<li><b>Accessors</b>
 <ul>
 <li><b>IsEmpty</b> -- returns true if the container is empty, false otherwise</li>
 <li><b>GetSize</b> -- returns the size (number of data elements)</li>
 <li><b>GetFirst</b> -- returns the first data element (by reference)</li>
 <li><b>GetLast</b> -- returns the last data element (by reference)</li>
 </ul>
 Note that error situations in the last two functions would occur if the 
 container was empty (this what the "dummy" item is for).
<br>&nbsp;
</li>

<li><b>Endpoint insert/removes</b>
 <ul>
 <li><b>InsertBack</b> -- insert the data (parameter) as the last item 
        in the container</li>
 <li><b>RemoveBack</b> -- remove the last element in the container. If it is 
	empty, just leave it empty</li>
 </ul>
<br>
</li>

<li><b>Iterator retrieval</b>
 <ul>
 <li><b>GetIterator</b> -- create and return an iterator that is 
positioned on the first data item in the vector. If empty, return 
default iterator</li>
 <li><b>GetIteratorEnd</b> -- create and return an iterator that is 
positioned on the last data item in the vector. If empty, return 
default iterator</li>
 </ul>
<br>
</li>

<li><b>SetCapacity</b>
<br>Change the vector's capacity (i.e. grow or shrink it) to the parameter 
value.  IF this would result in a smaller capacity than the current number 
of data elements, then update the size to match the new capacity.  (For 
example, if there are 10 items in the vector, but the capacity is set to 7, 
then we will lose the last three data items).
<br>&nbsp;
</li>
<li><b>Insert (2 parameters)</b> <br>The new data element (second 
parameter) should be inserted into the vector just <i>before</i> the spot 
referred to by the iterator (the first parameter).  If the container is empty, 
just insert the single item.  If the iterator does not refer to a valid 
spot, then insert at the end of the vector.  Function should return an 
iterator to the newly inserted piece of data.  Make sure to update this 
iterator appropriately before returning, as any change in capacity would 
change the location of the physical array.
<br>&nbsp;
</li>

<li><b>Remove (1 parameter)</b>
<br>This function should remove the data item that is given by the 
iterator (the parameter).  The function should return an iterator to the 
next data item (the one that was after the deleted data item).  If the initial 
vector was empty, there's nothing to delete -- so just leave it empty and 
return a default iterator.
<br>&nbsp;
</li>

<li><b>Remove (2 parameters)</b>
<br>This function should remove the data items in the RANGE that starts at 
the first iterator (pos1), up through but not including the second iterator 
(pos2). The function should return an iterator to the next data item (the 
one that was after the deleted data items).  If the initial vector was 
empty, there's nothing to delete -- so just leave it empty and return a 
default iterator.  If the first iterator is after the second iterator 
(error situation), don't delete anything, and just return the first 
iterator (pos1).
<br>&nbsp;
</li>

<li><b>Print</b>
<br>Should print the entire vector contents, front to back, separated by 
the delimiter given in the second parameter. This function 
may assume that the stored type T has an available insertion &lt;&lt; 
operator available for printing. Print to the stream given in the first 
parameter.  
<br>&nbsp;
</li>

<li><b><tt>operator+</tt></b>

<br>This is a standalone function that should return a TVector object that 
is the result of concatenating two TVector objects together -- in parameter 
order.  See driver.cpp program for examples.  (No, this function is NOT 
intended as a friend function.)


<br>&nbsp;
</li>

</ul>


<h3>2) class TVectorIterator</h3>

The TVectorIterator class has three member data variables -- a pointer to 
the data to which it currently refers, the size of the associated vector, 
and the index from the associated vector.  Note that the iterator is not 
intended to be built as a stand-alone item, but rather is created and 
returned BY member functions in the TVector class, so that it is associated 
with the vector.  We need data variables for size and index, because the 
array itself is not inside an iterator object.  The pointer will be used to 
access the data (i.e. it will be needed by the GetData function!)

<ul>

<li><b>Default constructor</b> -- a default iterator should just store the 
null pointer internally, as well as assume it is referring to an empty 
vector. We'll call this the "null iterator". </li>

<li><b>HasNext</b> -- returns true if there is another data element <i>after</i> 
the current one (in the vector), false otherwise
</li>

<li><b>HasPrevious</b> -- returns true if there is another data element <i>before</i> 
the current one, false otherwise
</li>

<li><b>Next</b> -- advances the iterator to the next data element after the 
current one (unless currently storing nullptr).  Returns an iterator 
to the new position.
</li>

<li><b>Previous</b> -- moves the iterator to the previous data element before 
the current one (unless currently storing nullptr).  Returns an iterator 
to the new position.  
</li>

<li><b>GetData</b> -- return the <i>data item</i> at the current iterator position. 
If the iterator is not pointing to a valid spot (i.e. null pointer), you 
can use the "dummy" that was defined previously.  Note that this is a 
return by reference. 
</li>

</ul>

<h4>A few general rules!</h4>
<ul>

<li>Define all of the functions for these classes in the file   
     <tt>tvector.hpp</tt></li>

<li>Always make sure there is ROOM in the array before inserting a new 
   item.  If you ever try to insert data, and the array is full (to capacity), 
   then increase the capacity by doubling it</li>

<li>Do NOT change any of the prototypes or member data declarations in the 
    <tt>tvector.h</tt> file at all.  All current declarations have the 
    intended prototypes, and they will need to work with my main programs.</li>

<li>Clean up dynamic memory in appropriate places and do not leave any 
memory leaks</li>

</ul>



<br>
<h3>3) Test Program</h3>

Create a test program of your own in the file 
<b><tt>mydriver.cpp</tt></b>.  You can use my provided driver.cpp as a 
general model of how to populate a vector.  Your test program 
should contain the following tests/illustrations at a minimum:

<ul>
<li>Tests of all of the functions</li>
<li>Tests that involve vectors of at least two different stored 
types.  Suggested types:  int, double, char, string</li>
<li>At least 10 tests of each of the following
 <ul>
 <li>InsertBack</li>
 <li>RemoveBack</li>
 <li>Insert (single item, iterator-based)</li>
 <li>Remove (single item, iterator-based)</li>
 <li>Remove (range, iterator-based</li>
 </ul>
 The tests for each of these should not be all in a row for any single 
one.  I.e. for best testing, make sure that insert/remove calls of a 
single function type are frequently interspersed between other types.  
(This way, a mistake in one will often be revealed by later calls to 
others)
</li>

<li>Clear illustrations of vector contents with Print before and after 
major sets of insert/delete tests.  Make your outputs readable and 
easy to follow for best testing/results.</li>

<li>At least one test that uses an iterator to traverse a vector front 
to back</li>

<li>At least one test that uses an iterator to traverse a vector back 
to front</li>

</ul>

<h3>4) makefile</h3>

Create a makefile that configures a build of both my provided driver 
(driver.cpp) and your test program (mydriver.cpp).  i.e. when you type 
"make" in the directory, it should compile and build both executables.  
Make your executables named "driver.x" and "mydriver.x", respectively.

<h3>5) General Requirements</h3>

<ul>
<li>Document your code appropriately so that it is readable and easy to 
navigate</li>

<li>You may use standard C++ I/O libraries, as well as class libraries 
like <tt>string</tt>.  You may <b>NOT</b> use any of the container class 
libraries from the STL</li>

<li>If you wish to add any helper functions to the TVector class, you may 
modify the tvector.h file for this purpose.  But do NOT change any of the 
expected interface function prototypes or add extra member data.  Any 
helper functions you write should be in the private section</li>

<li>Make sure your files compile and run on linprog.cs.fsu.edu with g++, 
using the C++11 standard compilation flag, or use "g++6", which has the 
C++11 features as a baseline.  This is where they will be tested and 
graded</li> 

</ul>



<hr>

<h3>Deliverables and submitting</h3>

These are the deliverable files you should submit:
<pre style="position: relative;">  tvector.h
  tvector.hpp
  mydriver.cpp
  makefile
<div class="open_grepper_editor" title="Edit &amp; Save To Grepper"></div></pre>

To submit, package up your files in a tar archive and upload this at the 
assignment submission link on the Canvas course site (in the 
"Assignments" section).  Your tar file should be named in this format, 
all lowercase:

<pre style="position: relative;">   <i>lastname_firstname_p1.tar</i>

   Example:  My tar file would be:    <b>myers_bob_p1.tar</b>
<div class="open_grepper_editor" title="Edit &amp; Save To Grepper"></div></pre>

<p>Note that in addition to the provided test cases, we will also test 
your program/classes using additional test programs.  Your program must 
be able to pass all such test cases to obtain a full score for the 
corresponding components.




</p></body></html>